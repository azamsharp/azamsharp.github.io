# Title Pending 



## Not all tests are created equal 

The main purpose of writing tests is to make sure that the software works as expected. Tests also gives you confidence that a change you made in one module is not going to break stuff in the same or other modules. Not all applications requires writing tests. If you are building a basic application with a straight forward domain then you can test the complete app using manual testing. Having said that in most professional environments, you are working with a complicated domain with business rules. These business rules form the basis on which company operates and generates revenue. 

This is the main reason that you should always write tests to cover business rules since it directly impacts the revenue generated by the company. 

>> Consider a scenario that you are writing an application for a bank. One of the business rules might be to charge overdraft fees in case of insufficient funds. Banks generate [billions of dollars income by just fees](https://www.depositaccounts.com/blog/banks-income-fees.html) alone. As a developer, you must write good quality tests to make sure that overdraft fee calculations works as expected.

In the same bank app, you may have features like rendering templates for emails or logging certain interactions. These features are important but may not produce the same return on investment as compared to charging overdraft fees. This means if the email template is not in the correct format then the banks are not going to loose millions of dollars and you will not receive a call in the middle of the night. 

>> If you are building a logging framework then it is essential that you thoroughly test the public API exposed by your framework. 

Next time you are writing a test, ask yourself how important this feature is for your business. If it is integral then make sure to test it thoroughly and go for high code coverage.  

## Mocks and Stubs 

## Test behavior not implementation 

One of the biggest mistake developers make is to focus on writing tests against the implementation details instead of the behavior of the application.

>> A trigger to add a test is the requirement, not a class or a function. 

Just because you added a new class or a function does not means that you will automatically start writing the test. Those are just implementation details and can change. You should write a test when a new business requirement is handed to you. 

Here are few examples of behaviors: 

1. When the customer withdraw amount and has insufficient funds then charge an overdraft fee.  
2. Another example. 

The behavior stems from the requirement of the project. Tests that checks the implementation detail instead of the behavior tends to be very brittle and can easily break when the implementation changes even though the behavior remains the same.  

For example let's say you are building a calculator. A simple calculator might look like the implementation below: 

```swift 
class Calculator {
    
    func add(a: Int, b: Int) -> Int {
        return a + b 
    }
}
```

A simple test for the Calculator is shown below: 

```swift 
final class CalculatorTests: XCTestCase {

    func test_add_two_numbers() throws {
       
        let calculator = Calculator()
        XCTAssertEqual(5, calculator.add(a: 2, b: 3))
    }
}
```

Pretty straight forward! Calculator is the public API and that is why we are testing that the Calculator is capable of adding two numbers.   

Now, let's assume that your Calculator needs to perform an operation using some fancy CalculatorService. Your Calculator class may look like the following: 

```swift 
class Calculator {
    
    private var calculatorService: CalculatorService
    
    init(calculatorService: CalculatorService) {
        self.calculatorService = calculatorService
    }
    
    func add(a: Int, b: Int) -> Int {
        calculatorService.add(a: a, b: b)
    }
}
```

Usually in these cases you introduce a mock object so you can mock the calls to the service. 

```swift 
protocol CalculatorServiceProtocol {
    func add(a: Int, b: Int) -> Int
}

// This is the public API
class Calculator {
    
    private var calculatorService: CalculatorServiceProtocol
    
    init(calculatorService: CalculatorServiceProtocol) {
        self.calculatorService = calculatorService
    }
    
    func add(a: Int, b: Int) -> Int {
        calculatorService.add(a: a, b: b)
    }
}

class CalculatorService: CalculatorServiceProtocol {
    func add(a: Int, b: Int) -> Int {
        a + b
    }
}

class MockedCalculatorService: CalculatorServiceProtocol {
    func add(a: Int, b: Int) -> Int {
        return a + b 
    }
}
```


## Stop testing your view models and controllers

## Mocking 

## The Ideal test 

## Resources 

## Conclusion 




